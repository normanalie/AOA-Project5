metric;help;value;color;details;
user_time;"Percentage of the application time spent in user code (meaning the time spent in the binary and external libraries specified in custom_categories).";100;;;
compilation_flags;;"+ measure: GNU C17 11.4.0 -march=znver3 -mmmx -mpopcnt -msse -msse2 -msse3 -mssse3 -msse4.1 -msse4.2 -mavx -mavx2 -msse4a -mno-fma4 -mno-xop -mfma -mno-avx512f -mbmi -mbmi2 -maes -mpclmul -mno-avx512vl -mno-avx512bw -mno-avx512dq -mno-avx512cd -mno-avx512er -mno-avx512pf -mno-avx512vbmi -mno-avx512ifma -mno-avx5124vnniw -mno-avx5124fmaps -mno-avx512vpopcntdq -mno-avx512vbmi2 -mno-gfni -mvpclmulqdq -mno-avx512vnni -mno-avx512bitalg -mno-avx512bf16 -mno-avx512vp2intersect -mno-3dnow -madx -mabm -mno-cldemote -mclflushopt -mclwb -mclzero -mcx16 -mno-enqcmd -mf16c -mfsgsbase -mfxsr -mno-hle -msahf -mno-lwp -mlzcnt -mmovbe -mno-movdir64b -mno-movdiri -mmwaitx -mno-pconfig -mpku -mno-prefetchwt1 -mprfchw -mno-ptwrite -mrdpid -mrdrnd -mrdseed -mno-rtm -mno-serialize -mno-sgx -msha -mshstk -mno-tbm -mno-tsxldtrk -mvaes -mno-waitpkg -mwbnoinvd -mxsave -mxsavec -mxsaveopt -mxsaves -mno-amx-tile -mno-amx-int8 -mno-amx-bf16 -mno-uintr -mno-hreset -mno-kl -mno-widekl -mno-avxvnni --param=l1-cache-size=32 --param=l1-cache-line-size=64 --param=l2-cache-size=512 -mtune=znver3 -g -O3 -fasynchronous-unwind-tables -fstack-protector-strong -fstack-clash-protection -fcf-protection  ";;;
__name;;"run_0";;;
speedup_if_fp_vect;"Optimistic speedup if all floating point instructions are vectorized in all analyzed loops. Memory instructions are not considered as vectorized.\nLower is better.";2.0621;medium;;
average_active_threads_count;"Sum over all threads of their active time divided by the application walltime.";0.97024518151712;;;
activity_ratio;"Sum over all threads of their CPU time divided by the sum of their walltime.";97.024518151712;;;
experiment_type;;"Sequential";;;
nb_loops_80_if_fp_vect;"Number of loops to optimize to get 80% of the speedup.\nLower is better.";1;;;
nb_loops_80_if_FP_only;"Number of loops to optimize to get 80% of the speedup.\nLower is better.";1;;;
speedup_if_clean;"Optimistic speedup if all instructions performing addresses computations and scalar integer computations have been deleted. \nLower is better.";1;good;;
profiled_time;"Application profiling duration in seconds. A too low value means the profiling does not last long enough, and it could lead to an inaccurate profile.<br><b>Too short run</b>: profiling results are not statistically significant (profiled time corresponds to 98.00 samples) and should not be used<br><b>Workaround</b>: Rerun with a longer workload and/or use sampling-rate=high/highest in lprof_params";0.49000000953674;bad;97.02% of the total time;
array_access_efficiency;"Processor friendly data layout. Accessing contiguous data is faster.\nHigher is better.";79.166666666667;good;;
speedup_if_perfect_MPI_OMP_PTHREAD;"Optimistic speedup if OpenMP, MPI and Pthread runtimes are perfect.\nLower is better.\nThis metric presents an estimation of the speed-up at application level if the MPI/OpenMP/Pthread behaviour is perfect.\nspeedup = MAX (time) / MAX (time without OpenMP, MPI and Pthread)";1;good;;
speedup_if_FP_only;"Optimistic speedup if only arithmetic floating point instructions are kept.\nLower is better.";1;good;;
nb_threads;;1;;;
compilation_options;"Global score based on basic options to use with the compiler to have good performance. Related report is based on the hottest profiled function, so it may not be fully representative of how each module was really compiled.";75;acceptable;;
GFlops;"Giga FLOP (FLoating point OPeration) per second. Higher is better.\n";0;;;
iterations_count;"Optimistic speedup available by increasing the number of iterations in loops. Having low iteration count loops can decrease performances.\nLower is better.";"Not Available";bad;;
speedup_if_fully_vect;;;;;
speedup_if_perfect_openmp;"Optimistic speedup if OpenMP is perfectly balanced.\nLower is better.";"Not Available";bad;;
nb_loops_80_if_L1;"Number of loops to optimize to get 80% of the speedup.\nLower is better.";"Not Available";bad;;
loops_time;"Percentage of the application time spent in loops (excluding loops present in modules not analyzed by the profiler). It represents 0.49 seconds.";100;;;
affinity_stability;"Sum over all threads of the max time spent on the same CPU divided by the sum over all threads of the thread walltime.";0;;;
average_active_time;"Sum of threads CPU time divided by thread count.";0.49000000953674;;;
speedup_if_L1;"Optimistic speedup if all memory accesses are located in the L1 cache for all analyzed loops.\nLower is better.";"Not Available";bad;;
speedup_if_perfect_MPI_OMP_PTHREAD_LOAD_DISTRIBUTION;"Optimistic speedup if OpenMP, MPI and Pthread runtimes are perfect and the load distribution if perfect.\nLower is better.\nThis metric presents an estimation of the speed-up at application level if most common parallel bottelnecks are perfect.\nspeedup = MAX (time) / AVG (time without OpenMP, MPI and Pthread)";1;good;;
total_power;"Average power spent during the execution (W).";"Not Available";;;
nb_loops_80_if_perfect_openmp;"Number of loops to optimize to get 80% of the speedup.\nLower is better.";"Not Available";bad;;
application_time;"Time spent by the application in seconds";0.50502699613571;;;
total_dram_read_throughput;"DRAM average read throughput";"0.00 B/s";;;
total_dram_write;"Total written memory traffic during the execution.";"0.00 B";;;
innerloops_time;"Percentage of the application time spent in innermost loops (excluding loops present in modules not analyzed by the profiler). It represents 0.49 seconds.";100;;;
total_energy;"Total energy spent during the execution (kJ).";"Not Available";;;
total_dram_read;"Total read memory traffic during the execution.";"0.00 B";;;
total_dram_write_throughput;"DRAM average written throughput";"0.00 B/s";;;
number_processes;;1;;;
crest_performance;"<TBD>.\n";"Not Implemented Yet";;;
flow_complexity;"Optimistic speedup available by reducing the number of paths in loops. Having multiple paths in a loop can prevent the compiler to vectorize the code, decreasing performances. The metric provides an estimation of a global speedup that can be achieved if all loops with more than two paths were fully vectorized.\nLower is better.";1;good;;
speedup_if_fully_vectorised;"Optimistic speedup if all instructions are vectorized in all analyzed loops.\nLower is better.";4.466;medium;;
nb_loops_80_if_fully_vect;"Number of loops to optimize to get 80% of the speedup.\nLower is better.";1;;;
nb_loops_80_if_clean;"Number of loops to optimize to get 80% of the speedup.\nLower is better.";1;;;
GBs;"<TBD>.\n";"Not Implemented Yet";;;
